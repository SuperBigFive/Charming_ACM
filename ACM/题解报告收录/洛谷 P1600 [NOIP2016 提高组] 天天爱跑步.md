## 洛谷 [P1600 [NOIP2016 提高组] 天天爱跑步](https://www.luogu.com.cn/problem/P1600)

### 题意描述

$n$ 个节点的无根树，$m$ 条路径，第 $i$ 个节点的点权为 $w[i]$，第 $i$ 条路径的起点和终点分别为 $s[i]$， $t[i]$，对于每个节点，求出多少条路径的出发点与其距离为 $w[i]$。

### 数据范围

$1 \leq n \leq 3\times 10^{5}$, $1 \leq m \leq 3\times 10^{5}$, $0 \leq w[i] \leq n$, $1 \leq s[i] \leq n$, $1 \leq t[i] \leq n$。

-----

### 题解1：线段树合并 + 树上差分

对于某条路径 $i$，它一定只影响 $s[i]$ 到 $t[i]$ 之间的节点 ~~(废话)~~。

按照线段树合并的套路，我们给每个节点开一个权值线段树，

对于树上的每个节点 $j$，其权值线段树上第 $i$ 个叶子节点的含义是深度；

节点 $j$ 的答案即为该权值线段树中 $dep[u] + w[u]$ 叶子节点和 $dep[u] - w[u]$ 叶子节点的值的和。

设 $s[i]$ 与 $t[i]$ 的 $lca$ 为 $LCA$，结合树上差分的思想，

在 $s[i]$ 的权值线段树中的 $dep[x]$ 叶子节点值加 $1$；

在 $LCA $ 的权值线段树中的 $dep[x]$ 叶子节点值减 $1$。

这里我们维护了 $s[i] $ 到 $LCA$ 之前的节点之间所有节点的信息。

为了维护 $LCA$ 到 $t[i]$ 之间的信息，

我们将起点 $s[i]$ 的深度以 $LCA$ 为对称轴进行一次翻转，

在 $t[i]$ 的权值线段树中的 $dep[LCA] * 2 - dep[u]$叶子节点值加 $1$;

在 $fa[LCA] $ 的权值线段树中的 $dep[x]$ 叶子节点值减 $1$。

通过以上四个修改操作，我们维护了 $s[i]$ 到 $t[i]$ 之间所有节点的信息。



### AC代码

```cpp
#include <bits/stdc++.h>
#define ll long long
#define int ll
using namespace std;
const int maxn = 3e5 + 5;

int n, m, tot;
int fa[maxn], son[maxn], siz[maxn], dep[maxn];
int top[maxn], w[maxn], root[maxn], ans[maxn];
int node[maxn * 60], ls[maxn * 60], rs[maxn * 60];
vector <int> adj[maxn];

void init () {}

void dfs1 (int f, int u, int d) {
	fa[u] = f, siz[u] = 1, dep[u] = d;
	for (auto it : adj[u]) {
		if (it == f) continue;
		dfs1 (u, it, d + 1);
		siz[u] += siz[it];
		if (siz[it] > siz[son[u]]) son[u] = it;
	}
}

void dfs2 (int f, int u, int tp) {
	top[u] = tp;
	if (son[u]) dfs2 (u, son[u], tp);
	for (auto it : adj[u]) {
		if (it == f || it == son[u]) continue;
		dfs2 (u, it, it);
	}
}

int lca (int x, int y) {
	while (top[x] != top[y]) {
		if (dep[top[x]] < dep[top[y]]) swap (x, y);
		x = fa[top[x]];
	}
	return dep[x] < dep[y] ? x : y;
}

void modify (int &cnt, int l, int r, int d, int k) {
	if (!cnt) cnt = ++tot;
	if (l == r) {
		node[cnt] += k;
		return;
	}
	int mid = l + r >> 1;
	if (d <= mid) modify (ls[cnt], l, mid, d, k);
	else modify (rs[cnt], mid + 1, r, d, k);
}

int merge (int x, int y, int l, int r) {
	if (!x || !y) return x + y;
	int now = ++tot;
	if (l == r) {
		node[now] = node[x] + node[y];
		return now;
	}
	int mid = l + r >> 1;
	ls[now] = merge (ls[x], ls[y], l, mid);
	rs[now] = merge (rs[x], rs[y], mid + 1, r);
	return now;
}

int query (int cnt, int l, int r, int pos) {
	if (l == r) return node[cnt];
	int mid = l + r >> 1;
	if (pos <= mid) return query (ls[cnt], l, mid, pos);
	return query (rs[cnt], mid + 1, r, pos);
}

void dfs (int f, int u) {
	for (auto it : adj[u]) {
		if (it == f) continue;
		dfs (u, it);
		root[u] = merge (root[u], root[it], 1, n << 1);
	}
	if (w[u] && n + dep[u] + w[u] <= n << 1)
	ans[u] += query (root[u], 1, n << 1, n + dep[u] + w[u]);
	ans[u] += query (root[u], 1, n << 1, n + dep[u] - w[u]);
}

void charming () {
	cin >> n >> m;
	for (int i = 1, u, v; i < n; ++i) {
		cin >> u >> v;
		adj[u].emplace_back (v);
		adj[v].emplace_back (u);
	}
	dfs1 (0, 1, 1), dfs2 (0, 1, 1);
	for (int i = 1; i <= n; ++i) cin >> w[i];
	for (int i = 1, u, v, LCA; i <= m; ++i) {
		cin >> u >> v;
		LCA = lca (u, v);
		modify (root[u], 1, n << 1, n + dep[u], 1);
		modify (root[LCA], 1, n << 1, n + dep[u], -1);
		modify (root[v], 1, n << 1, n + dep[LCA] * 2 - dep[u], 1);
		modify (root[fa[LCA]], 1, n << 1, n + dep[LCA] * 2 - dep[u], -1);
	}
	dfs (0, 1);
	for (int i = 1; i <= n; ++i) cout << ans[i] << " \n"[i == n];
}

signed main () {
	charming ();
	return 0;
}
```

-----

### 收获&总结

没想到线段树合并不仅能维护子树问题，还能解决一些路径上的问题。

树上差分，感觉就像是赋予一种”影响“，通过遍历累积的操作，在适当位置添加“影响“，适当位置去除”影响“，就能够实现链操作变成点操作。

