## 洛谷  [P2444 [POI2000]病毒](https://www.luogu.com.cn/problem/P2444)

### 题目描述

给定 $n$ 个 $01$ 串，试问，是否存在一个无限长的 $01$ 串， 使得给定的任意一个 $01$ 串都不在其出现过。

### 数据范围

$1 \leq n \leq 2000$，所有给定的 $01$ 串的总长度不超过 $3 \times 10^4$。

-----

### 题解报告

相当于AC自动机反过来用，一般是从字符串中找匹配，现在是找一个不存在匹配的字符串。

考虑这样的字符串的性质。假定在由给定的 $01$ 串建造的 $trie$ 树中，某 $01$ 串终止的节点标记危险节点（若某节点的 $fail$ 指针所指向的节点为危险节点，那么我们也标记该节点为危险节点），当我们遍历该无限长的 $01$ 串时，在 $trie$ 树上从未到达过危险节点。因为其无限长，所以必定是在跳 $fail$ 指针的时候走入了循环中。

我们把 $fail$ 指针当作边，与 $trie$ 树结合成 $trie$ 图，存在符合题意的 $01$ 串的充要条件就是，从 $trie$ 图出发，可以到达一个不含危险节点的环。这里的“可以”是指到达环之前未曾达到过危险节点。

所以在 $trie$ 图 $dfs$ 一遍，找环即可。

### AC代码：

```cpp
#include <bits/stdc++.h>
#define ll long long
#define int ll
using namespace std;
const int maxn = 2e5 + 5;

int n, len, tot;
int fail[maxn];
int trie[maxn][2];
char s[maxn];
bool vis[maxn], in[maxn], en[maxn];

void init () {
	tot = 0;
	fill (vis, vis + maxn, false);
	fill (in, in + maxn, false);
	fill (en, en + maxn, false);
}

void ins () {
	int now = 0, num;
	for (int i = 1; i <= len; ++i) {
		num = s[i] - '0';
		if (!trie[now][num]) trie[now][num] = ++tot;
		now = trie[now][num];
	}
	en[now] = true;
}

void get_fail () {
	queue <int> q;
	if (trie[0][0]) q.push (trie[0][0]);
	if (trie[0][1]) q.push (trie[0][1]);
	int now;
	while (!q.empty ()) {
		now = q.front ();
		q.pop ();
		for (int i = 0; i <= 1; ++i) {
			if (trie[now][i]) {
				fail[trie[now][i]] = trie[fail[now]][i];
				en[trie[now][i]] |= en[fail[trie[now][i]]];
				q.push (trie[now][i]);
			}
			else trie[now][i] = trie[fail[now]][i];
		}
	}
}

void dfs (int now) {
	if (in[now]) {
		cout << "TAK" << endl;
		exit (0);
	}
	if (vis[now] || en[now]) return;
	vis[now] = in[now] = true;
	dfs (trie[now][0]);
	dfs (trie[now][1]);
	in[now] = false;
}

void charming () {
	init ();
	cin >> n;
	for (int i = 1; i <= n; ++i) {
		cin >> s + 1;
		len = strlen (s + 1);
		ins ();
	}
	get_fail ();
	dfs (0);
	cout << "NIE" << endl;
}

signed main () {
	charming ();
	return 0;
}
```

-----

### 收获&总结

加深对 $AC$ 自动机和 $trie$ 树/图的理解，指针不断在 $trie$ 树上移动、跳 $fail$ 的过程，就是字符串在不断的与若干模式串匹配的过程，指针停在哪个位置，就代表着字符串与所有模式串的最大匹配情况。

正确的解题思路，通过观察题目所求字符串的性质，把限制条件转化成更本质的条件。