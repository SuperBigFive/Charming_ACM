# G.Arrange the desktop

## 题解

观察后可发现，摆放整齐后对应的位置的纵坐标一定是不大于待摆放图标的纵坐标的，所以计算移动距离时关于 $y$ 轴的绝对值是可以去掉的，原问题等价于 $x$ 轴上求 $k$ 个点移动到另外 $k$ 个位置的最小移动总距离。

不难想到，将点和位置均按 $x$ 坐标大小排序后，第 $i$ ($1 \leq i \leq k$) 个点移动到第 $i$ 个位置，按照这种移动方式移动的总距离是最小的（即每次把剩下的最左边的点移动到剩下的最左边的位置）。

假设 $x$ 轴上两个点，$x_1, x_2$，$x_2$ 位于 $x_1$ 右边，即 $x_2 \geq x_1$。则 $x_2$ 匹配的位置 $y_2$ 一定也要大于等于 $x_1$ 匹配的位置 $y_1$。否则，若 $x_1 \leq y_2 \leq x_2$，则会多移动 $x_2 - x_1$ 的距离。

### 参考代码（C++）：

```cpp
#include <bits/stdc++.h>
#define ll long long
#define int ll
using namespace std;
const int N = 2e3 + 5;

int n, m, k;

void init () {}

void charming () {
	init ();
	cin >> n >> m >> k;
	vector <pair <int, int> > p1, p2;
	vector <string> mp (n + 1);
	for (int i = 1; i <= n; ++i) {
		cin >> mp[i], mp[i] = '#' + mp[i];
	}
	for (int j = 1; j <= m; ++j) {
		for (int i = 1; i <= n; ++i) {
			if ((i - 1) * m + j <= k && mp[i][j] == '0') 
			p1.emplace_back (make_pair (i, j));
			if ((i - 1) * m + j > k && mp[i][j] == '1')
			p2.emplace_back (make_pair (i, j));
		}
	}
	int res = 0, siz = p1.size ();
	for (int i = 0; i < siz; ++i) {
		auto [x1, y1] = p1[i];
		auto [x2, y2] = p2[i];
		res += abs (x1 - x2) + abs (y1 - y2);
	}
	cout << res << endl;
}

signed main () {
	charming ();
	return 0;
}
```

### 出题人：Charming