## 洛谷 [P4396 [AHOI2013]作业](https://www.luogu.com.cn/problem/P4396)

### 题目描述

给定一个长度为 $n$ 的数列，$m$ 次询问，每次询问区间 $[l, r]$ 内大小范围在 $[a, b]$ **数**的个数和**数值**的个数。

### 数据范围

$n \leq 100000，m \leq 100000，$读入的数字均为 $[1,10^{5}]$ 内的正整数。 

-----

### 题解报告

莫队的入门题是询问区间内数值的个数，没有大小范围的限制。

想到一个很慢的做法，建一棵权值线段树，

指针每移动一次就修改一次，复杂度 $O(n\sqrt {m} log(n))$，显然会 $T$。

考虑到我们在做入门题的时候，实际上每次询问，问的是 $cnt[]$ 整个数组中不为 $0$ 的个数。

而这道题实际上问的是 $cnt[l]\  \sim \ cnt[r]$ 中不为 $0$ 的个数和 $cnt[]$ 数组区间求和。

假如我们的问题就是求数组区间求和和区间内不为 $0$ 的个数，

那么这个问题其实可以用分块（分块大法好！） $O(m\sqrt n)$ 求解的。

定义 $kind[i]$ 为第 $i$ 个块中数值的个数， $sum[i]$ 为第 $i$ 个块中数的个数，

每次指针移动的时候可以 $O(1)$ 维护这两个信息。

这个方法，实际上是把修改和查询分成两个步骤了，修改用莫队 $O(n\sqrt m)$，查询用分块 $O(m\sqrt n)$。

见过权值线段树，想不到竟然还可以”权值分块“。

### AC代码：

```cpp
#include <bits/stdc++.h>
#define ll long long
#define int ll
using namespace std;
const int maxn = 1e5 + 5;

struct Query {
	int l, r;
	int a, b;
	int tot;
}q[maxn];
int n, m, blo;
int arr[maxn], cnt[maxn];
int bel[maxn], kind[maxn], sum[maxn];
pair <int, int> ans[maxn];

void init () {}

pair <int, int> force (int a, int b) {
	pair <int, int> tmp;
	tmp.first = tmp.second = 0;
	for (int i = a; i <= b; ++i) {
		if (cnt[i]) ++tmp.second;
		tmp.first += cnt[i];
	}
	return tmp;
}

void get_ans (int id, int a, int b) {
	int bela = bel[a], belb = bel[b];
	if (bela == belb || bela == belb - 1)	{
		ans[id] = force (a, b);
		return;
	}
	pair <int, int> tmp1, tmp2;
	int ena = bela * blo, enb = (belb - 1) * blo + 1;
	tmp1 = force (a, ena);
	tmp2 = force (enb, b);
	ans[id].first = tmp1.first + tmp2.first;
	ans[id].second = tmp1.second + tmp2.second;
	for (int i = bela + 1; i < belb; ++i) {
		ans[id].first += sum[i];
		ans[id].second += kind[i];
	}
}

void del (int id) {
	--cnt[arr[id]];
	if (cnt[arr[id]] == 0) --kind[bel[arr[id]]];
	--sum[bel[arr[id]]];
}

void add (int id) {
	++cnt[arr[id]];
	if (cnt[arr[id]] == 1) ++kind[bel[arr[id]]];
	++sum[bel[arr[id]]];
}
	
void charming () {
	cin >> n >> m;
	blo = sqrt (maxn);
	for (int i = 1; i <= n; ++i) {
		cin >> arr[i];
		bel[i] = (i - 1) / blo + 1;
	}
	for (int i = 1; i <= m; ++i) {
		cin >> q[i].l >> q[i].r;
		cin >> q[i].a >> q[i].b;
		q[i].tot = i;
	}
	sort (q + 1, q + 1 + m, [] (Query &x, Query &y) {
		if (bel[x.l] != bel[y.l]) return bel[x.l] < bel[y.l];
		return bel[x.r] < bel[y.r];
	});
	int l = 1, r = 0;
	for (int i = 1; i <= m; ++i) {
		int ql = q[i].l, qr = q[i].r;
		while (r < qr) add (++r);
		while (r > qr) del (r--);
		while (l < ql) del (l++);
		while (l > ql) add (--l);
		get_ans (q[i].tot, q[i].a, q[i].b);
	}
	for (int i = 1; i <= m; ++i) 
	cout << ans[i].first << " " << ans[i].second << endl;
}

signed main () {
	charming ();
	return 0;
}
```

-----

### 收获&总结

好家伙，暴力 + 暴力，这道题肯定很受深爱暴力数据结构的人喜欢。

对 $cnt[]$ 数组单独用另一个算法维护是我没想到的，思维能力太差了。

看题解的时候一看到这个操作，就知道怎么写了，之前刷莫队题目的时候没遇到这样的题，形成思维定势了。

没有深度思考 $cnt[]$ 数组的本质。

感觉莫队修改操作也只能 $O(1)$ 了，其他花样估计也只能在 $cnt[]$ 数组上整了。